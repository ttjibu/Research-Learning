\documentclass[UTF8]{ctexart}


\title{\LaTeX}
\author{张子健, 王颜睿, 梁铭恩, 陈亮沛, 戴益翔}

\begin{document}
\begin{center}
	\begin{abstract}
		a
	\end{abstract}
	\begin{keywords}
		a
	\end{keywords}
\end{center}

\section{Intro}
\label{sec:introduction}
在计算机科学中，时间复杂性，又称时间复杂度，算法的时间复杂度是一个函数，它定性描述该算法的运行时间。这是一个代表算法输入值的字符串的长度的函数。时间复杂度常用大O符号表述，不包括这个函数的低阶项和首项系数。使用这种方式时，时间复杂度可被称为是渐近的，亦即考察输入值大小趋近无穷时的情况。

\subsection{Heapsort}
\label{subsec:heapsort}
堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。

对于一个大小为n的无序序列，每一次读入的元素ai，都会被插入到堆中，维护堆需要log i 次操作。读入n次，需要做sigma（i=1,n）log i次。
在输出结果时，第i次直接输出堆顶的元素（最大或最小），然后删除堆顶并维护堆，需要做log(n-i)次操作。输出n次，需要做sigma（i=1,n）log i次。
综上，整个排序过程，一共要做2* sigma（i=1,n）log i次操作，所以堆排序的时间复杂度为O(nlogn)的数量级。

\subsection{Merge Sort}
\label{subsec:mergesort}
归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。归并排序是一种稳定的排序方法。
对于读入和输出一个大小为n的无序序列，各需要n次操作。

排序时，需要运用递归，先排好当前序列[left , right]中[left,mid]和[mid+1,right]。对于已经排好序的两个子序列，将两个序列各自第一个元素中更小或更大的（如果相同，则选择）加入辅助数组，然后后移操作过的序列的指针，直到两个序列都为空。由于每个子序列中的第一个元素必定是该序列的最值，则两个子序列中各自第一个元素的最值必然是整个序列的最值，就能保证辅助数组的有序性，所以该步骤的正确性是有保证的。

由于每次这个步骤需要n次操作，根据二分法需要分logn次，所以需要nlogn此操作。加上输入和输出，该算法的复杂度为O(logn)。

\subsection{Pupple Sort}
\label{subsec:pupplesort}
冒泡算法的基本思想是依次把最大(最小)数浮动到正确位置。

冒泡算法对数据进行N次迭代，每次迭代都按顺序比较序列的连续两个元素并把较大数往后移动，
从而实现每次迭代将一个未排好的最大值排到正确位置，在N次后必然排好序列。

由于进行n次迭代，每次迭代遍历一次序列，故时间复杂度为$O(N^2)$。

而空间除原数据外没有与N有关的额外存储，故空间复杂度为$O(1)$。

\subsection{Insertion Sort}
\label{subsec:insertionsort}
插入算法的基本思想是在已排序好的序列里插入未排序的元素（如打扑克时人们常用的排序）。

插入排序要进行n次迭代，每次迭代将一个无序元素插入到有序序列，进行n次后所有无序元素均插入到有序序列，排序完成。

由于进行了n次迭代，因此时间复杂度关键取决于插入操作。显然，最好情况是有序序列，插入过程只需比较一次，时间复杂度为 $O(N)$ ；
最坏情况是倒序序列，插入过程平均比较 $n \over 2$ 次，时间复杂度为 $O(\frac{n^2}{2})$

与冒泡排序相同，插入排序没有使用额外空间，空间复杂度为 $O(1)$

\section{Method}
\label{sec:method}

\section{Experiments}
\label{sec:experiments}

\section{Conclusion}
\label{sec:conclusion}

\end{document}
