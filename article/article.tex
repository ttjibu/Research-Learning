\documentclass[UTF8]{ctexart}
\usepackage{indentfirst}
\usepackage{apacite}
\usepackage{graphicx}
\bibliographystyle{apacite}

\title{比较不同排序算法的效率}
\author{张子健, 王颜睿, 梁铭恩, 陈亮沛, 戴益翔 \\ 佛山市第一中学}

\begin{document}
\maketitle
\begin{abstract}
	计算机科学中，时间复杂度往往被用于衡量排序算法的执行效率。但是在工程问题中，时间复杂度所忽略的低阶项以及常数因子往往成为限制实践的重要因素。在这篇论文中，我们分别编写六种常见比较排序（冒泡排序、选择排序、插入排序、堆排序、快速排序、归并排序）的实现并比较它们的运行效率。为了排除计算机体系架构和编译模式的影响，我们不计算程序运行时间，而是统计算法运行过程中发生的元素比较和元素赋值的次数。
\end{abstract}

\section{引言}

\section{相关工作}

\paragraph{时间复杂度}
在计算机科学中，时间复杂度 \cite{cormen1990introduction} 往往被用于衡量一个算法的执行效率。这是一个代表算法输入值的字符串的长度的函数。时间复杂度常用大$O$符号表述，不包括这个函数的低阶项和首项系数。使用这种方式时，时间复杂度可被称为是渐近的，亦即考察输入值大小趋近无穷时的情况。解决同一个问题，时间复杂度越低，该算法效率越高。算法的时间复杂度忽略了所有的低阶项和常数时间，因此只能定性描述算法的运行效率。但是，在工程问题中，算法的常数时间往往对最终的效果有明显的影响。因此，横向对比不同排序算法的实际运行效率很有必要。

\paragraph{堆排序}
堆排序\cite{cormen1990introduction}是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。对于一个大小为$n$的无序序列，每一次读入的元素$a_i$，都会被插入到堆中，维护堆需要$\log i$次操作。读入$n$次，需要做$\sum_{i=1}^{n}\log i$次。在输出结果时，第i次直接输出堆顶的元素（最大或最小），然后删除堆顶并维护堆，需要做$\log (n-i)$次操作。输出n次，需要做$\sum_{i=1}^{n}\log i$次。综上，整个排序过程，一共要做$2\sum_{i=1}^{n}\log i$次操作，所以堆排序的时间复杂度为$O(n \log n)$的数量级。

\paragraph{归并排序}
归并排序\cite{cormen1990introduction}是建立在归并操作上的一种有效的排序算法,该算法是采用分治法的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。归并排序是一种稳定的排序方法。对于读入和输出一个大小为n的无序序列，各需要n次操作。排序时，需要运用递归，先排好当前序列。对于已经排好序的两个子序列，将两个序列各自第一个元素中更小或更大的（如果相同，则选择）加入辅助数组，然后后移操作过的序列的指针，直到两个序列都为空。由于每个子序列中的第一个元素必定是该序列的最值，则两个子序列中各自第一个元素的最值必然是整个序列的最值，就能保证辅助数组的有序性，所以该步骤的正确性是有保证的。由于每次这个步骤需要n次操作，根据二分法需要分$\log n$次，所以需要$n \log n$此操作。加上输入和输出，该算法的复杂度为$O(\log n)$。

\paragraph{冒泡排序}
冒泡算法\cite{cormen1990introduction}的基本思想是依次把最大(最小)数浮动到正确位置。冒泡算法对数据进行N次迭代，每次迭代都按顺序比较序列的连续两个元素并把较大数往后移动，从而实现每次迭代将一个未排好的最大值排到正确位置，在N次后必然排好序列。由于进行n次迭代，每次迭代遍历一次序列，故时间复杂度为$O(N^2)$。而空间除原数据外没有与N有关的额外存储，故空间复杂度为$O(1)$。

\paragraph{插入排序}
插入算法的基本思想是在已排序好的序列里插入未排序的元素（如打扑克时人们常用的排序）。插入排序\cite{cormen1990introduction}要进行n次迭代，每次迭代将一个无序元素插入到有序序列，进行n次后所有无序元素均插入到有序序列，排序完成。由于进行了n次迭代，因此时间复杂度关键取决于插入操作。显然，最好情况是有序序列，插入过程只需比较一次，时间复杂度为 $O(N)$ ；最坏情况是倒序序列，插入过程平均比较 $n \over 2$ 次，时间复杂度为 $O(\frac{n^2}{2})$与冒泡排序相同，插入排序没有使用额外空间，空间复杂度为 $O(1)$

\section{方法}
我们根据\citeauthor{cormen1990introduction}的伪代码分别编写六种常见比较排序（冒泡排序、选择排序、插入排序、堆排序、快速排序、归并排序）的测试程序，追踪每一次定义在源程序代码中的元素比较和变量赋值并统计最终结果。我们采用同一个程序，仅改变用于排序的函数以得到结果，并最大限度避免因为人为程序编写误差导致的结果偏差。

\paragraph{样本生成}
对于每个排序算法，我们选择数据规模$2^7$、$2^8$、$2^9$······$2^19$、$2^20$各20组（部分时间复杂度为$O(n^2)$的排序算法由于计算量过大不能取到$2^20$数据规模）。对于每个数据规模，我们生成了20组互不相同的，值范围为$[0, 1)$的数据。

\section{实验}
我们在配备英特尔\textregistered 酷睿\texttrademark i3-6100处理器、4GB DDR3-1600MHz内存以及Ubuntu 18.04 LTS与GNU C++ Compiler 4.8.5的计算机上运行我们的样例程序。

\begin{figure}[t]
\includegraphics[width=\textwidth]{fig1.png}
\caption{六种排序算法的比较}
\end{figure}

\section{结语}

\renewcommand{\refname}{参考文献}
\bibliography{article}
\end{document}
